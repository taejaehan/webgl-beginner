<!DOCTYPE html>
<head>
<title>webgl han test 03</title>
<script type='text/javascript' src='js/gl-matrix-min.js'></script>
<script type='text/javascript' src='js/utils.js'></script>
</head>

<body>
<canvas id='canvas-element-id' width='800' height='400'>
Your browser does not support the HTML5 canvas element.
</canvas>
<!-- Vertex Shader -->
<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat4 uNMatrix;

    uniform vec3 uLightDirection;   //light direction
    uniform vec4 uLightDiffuse;     //light color
    uniform vec4 uMaterialDiffuse;  //object color

    varying vec4 vFinalColor;

    void main(void) {
        //Transformed normal position
        //버텍스 법선 벡터 정규화
        vec3 N = normalize(vec3(uNMatrix * vec4(aVertexNormal, 1.0)));

        //Normalize light to calculate lambertTerm
        //광향반대 반향의 벡터 정규화
        vec3 L = normalize(uLightDirection);

        //Lambert's cosine law
        //람베르트 계수는 버텍스 법선 벡터와 광향반대 반향의 벡터 내적으로 구한다
        float lambertTerm = dot(N,-L);

        //Final Color
        //램버시안 반사 모델은 재질 분산광 속성과 빛 분산광 속성의 상호작용만을 고려한다
        vec4 Id = uMaterialDiffuse * uLightDiffuse * lambertTerm;
        vFinalColor = Id;
        vFinalColor.a = 1.0;    //alpha(세번째값) 1.0

        //Transformed vertex position
        //최종색상은 연관된 프래그먼트로 계속 보간된다
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    }
</script>
<!-- Fragment Shader -->
<script id="shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
    precision highp float;
    #endif

    varying vec4  vFinalColor;

    void main(void)  {
        // gl_FragColor = vec4(0.5, 0.9, 0.2, 1.0); //Green
        gl_FragColor = vFinalColor;
    }
</script>


<script id='code-js' type="text/javascript">
    var gl = null; // WebGL context
    var prg = null; // The program (shaders)
    var c_width = 0; // Variable to store the width of the canvas
    var c_height = 0; // Variable to store the height of the canvas

    var mvMatrix = mat4.create(); // The Model-View matrix
    var pMatrix = mat4.create(); // The projection matrix

    /*-----------------------------------------------------*/
    var nMatrix = mat4.create(); // The normal matrix
    /*-----------------------------------------------------*/

    var sphereVerticesBuffer;
    var sphereIndicesBuffer;

    /*-----------------------------------------------------*/
    var sphereNormalsBuffer; //VBO for Normals
    /*-----------------------------------------------------*/

    var vertices;
    var indices;
    /*-----------------------------------------------------*/
    var normals; //JavaScript Array for Normals
    /*-----------------------------------------------------*/

    var angle = 0;

    /**
     * The program contains a series of instructions that tell the Graphic Processing Unit (GPU)
     * what to do with every vertex and fragment that we pass it. 
     * The vertex shader and the fragment shader together are called the program.
     */
    function initProgram() {
        var fragmentShader = utils.getShader(gl, "shader-fs");
        var vertexShader = utils.getShader(gl, "shader-vs");

        prg = gl.createProgram();
        gl.attachShader(prg, vertexShader);
        gl.attachShader(prg, fragmentShader);
        gl.linkProgram(prg);

        if (!gl.getProgramParameter(prg, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(prg);

        prg.aVertexPosition = gl.getAttribLocation(prg, "aVertexPosition");
        prg.aVertexNormal = gl.getAttribLocation(prg, "aVertexNormal");

        prg.uPMatrix = gl.getUniformLocation(prg, "uPMatrix");
        prg.uMVMatrix = gl.getUniformLocation(prg, "uMVMatrix");
        prg.uNMatrix = gl.getUniformLocation(prg, "uNMatrix");

        prg.uMaterialDiffuse = gl.getUniformLocation(prg, "uMaterialDiffuse");
        prg.uLightDiffuse = gl.getUniformLocation(prg, "uLightDiffuse");
        prg.uLightDirection = gl.getUniformLocation(prg, "uLightDirection");

    }

    function initLights() {
        gl.uniform3fv(prg.uLightDirection, [ 0.0, -1.0, -1.0 ]);
        gl.uniform4fv(prg.uLightDiffuse, [ 1.0, 1.0, 1.0, 1.0 ]);
        gl.uniform4fv(prg.uMaterialDiffuse, [ 0.5, 0.8, 0.1, 1.0 ]);
    }

    /**
     * This function generates SPHERE data and creates the buffers
     */
    function initBuffers() {
        vertices =[1.5, 0, 0, 
            -1.5, 1, 0, 
            -1.5, 0.809017, 0.587785,
            -1.5, 0.309017, 0.951057, 
            -1.5, -0.309017, 0.951057, 
            -1.5, -0.809017, 0.587785,
            -1.5, -1, 0, 
            -1.5, -0.809017, -0.587785,
            -1.5, -0.309017, -0.951057, 
            -1.5, 0.309017, -0.951057, 
            -1.5, 0.809017, -0.587785];

        indices = [0, 1, 2,
            0, 2, 3,
            0, 3, 4,
            0, 4, 5,
            0, 5, 6,
            0, 6, 7,
            0, 7, 8,
            0, 8, 9,
            0, 9, 10,
            0, 10, 1];

        normals = utils.calculateNormals(vertices, indices);

        sphereVerticesBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, sphereVerticesBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices),
                gl.STATIC_DRAW);

        sphereNormalsBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, sphereNormalsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals),
                gl.STATIC_DRAW);

        sphereIndicesBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndicesBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices),
                gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

    }

    /**
     * Main rendering function. Called every 500ms according to WebGLStart function (see below)
     */
    function drawScene() {
        gl.clearColor(0.3, 0.3, 0.3, 1.0);
        gl.clearDepth(100.0);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
        gl.viewport(0, 0, c_width, c_height);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.perspective(45, c_width / c_height, 0.1, 10000.0, pMatrix);

        mat4.identity(mvMatrix);
        mat4.translate(mvMatrix, [ 0.0, 0.0, -5.0 ]); //Sets the camera to a reasonable distance to view the part
        mat4.rotate(mvMatrix,angle*Math.PI/180, [0,1,1]);
        gl.uniformMatrix4fv(prg.uMVMatrix, false, mvMatrix);
        gl.uniformMatrix4fv(prg.uPMatrix, false, pMatrix);

        mat4.set(mvMatrix, nMatrix);
        mat4.inverse(nMatrix);
        mat4.transpose(nMatrix);

        gl.uniformMatrix4fv(prg.uNMatrix, false, nMatrix);

        try {
            gl.enableVertexAttribArray(prg.aVertexPosition);
            gl.enableVertexAttribArray(prg.aVertexTexCoord);
            gl.enableVertexAttribArray(prg.aVertexNormal);

            //2. bind buffers 
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVerticesBuffer);
            gl.vertexAttribPointer(prg.aVertexPosition, 3, gl.FLOAT, false, 0,
                    0);

            gl.bindBuffer(gl.ARRAY_BUFFER, sphereNormalsBuffer);
            gl.vertexAttribPointer(prg.aVertexNormal, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndicesBuffer);
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
            // gl.drawElements(gl.LINE_LOOP, indices.length, gl.UNSIGNED_SHORT, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        } catch (err) {
            alert(err);
            message(err.description);
        }
    }

    var angle = 0;
    /**
    * Render Loop
    */
    function renderLoop() {
        angle = angle+ 1;
        //window.requestAnimFrame 함수는 웹지엘을 지원하는 브라우저에서 동작함. 브라우저나 브라우저 탭에 포커스가 들어오면 렌더링 함수를 호출하도록 디자인됨. 포커스 아웃되면 자동으로 멈춤(but 모든 브라우저 미지원)
        requestAnimFrame(renderLoop);
        drawScene();
    }

    /**
     * Entry point. This function is invoked when the page is loaded
     */
    function runWebGLApp() {
        //Obtains a WebGL context
        gl = utils.getGLContext("canvas-element-id");
        //Initializes the program (shaders) 
        initProgram();
        //Initializes the buffers that we are going to use
        initBuffers();
        //Initializes lights
        initLights();
        //Renders the scene!
        renderLoop();
    }
    runWebGLApp();
</script>

</body>
</html>