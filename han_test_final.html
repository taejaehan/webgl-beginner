<html>

<head>
<title>WebGL Beginner's Guide - Chapter 5 - Parametric Curves - Bouncing Balls</title>
<meta http-equiv='content-type' content='text/html; charset=ISO-8859-1'>

<!-- GUI Libraries //-->
<script type='text/javascript' src='js/gui/jquery-1.5.1.min.js'></script>
<script type='text/javascript' src='js/gui/jquery-ui-1.8.13.custom.min.js'></script> 
<script type='text/javascript' src='js/gui/colorpicker.js'></script>
<script type='text/javascript' src='js/gui/prettify.js'></script>
<script type='text/javascript' src='js/gui/codeview.js'></script>
<!-- MATH Libraries //-->
<script type='text/javascript' src='js/math/gl-matrix-min.js'></script>
<!-- WEBGL Libraries //-->
<script type='text/javascript' src='js/webgl/Globals.js'></script>
<script type='text/javascript' src='js/webgl/Utils.js'></script>
<script type='text/javascript' src='js/webgl/Program.js'></script>
<script type='text/javascript' src='js/webgl/Scene.js'></script>
<script type='text/javascript' src='js/webgl/Axis.js'></script>
<script type='text/javascript' src='js/webgl/Floor.js'></script>
<script type='text/javascript' src='js/webgl/Camera.js'></script>
<script type='text/javascript' src='js/webgl/CameraInteractor.js'></script>
<script type='text/javascript' src='js/webgl/SceneTransforms.js'></script>
<script type='text/javascript' src='js/webgl/Texture.js'></script>
<script type='text/javascript' src='js/webgl/WebGLApp.js'></script>
<script type='text/javascript' src='js/webgl/Picker.js'></script>

<script id="shader-vs" type="x-shader/x-vertex">

attribute vec3 aVertexPosition;
attribute vec3 aVertexNormal;
attribute vec4 aVertexColor;

uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;
uniform mat4 uNMatrix;
uniform vec3 uLightPosition;
uniform vec4 uMaterialDiffuse;
uniform bool uWireframe;
uniform bool uPerVertexColor;
uniform bool uUpdateLight;
uniform vec3 uTranslation;
uniform bool uTranslate;

varying vec3 vNormal;
varying vec3 vLightRay;
varying vec3 vEyeVec;
varying vec4 vFinalColor;

uniform bool uOffscreen; 


void main(void) {
	
    if (uWireframe) {
        if (uPerVertexColor){
            vFinalColor = aVertexColor;
        }
        else{
            vFinalColor = uMaterialDiffuse;
        }
    }
    
    if(uOffscreen){
        vFinalColor = uMaterialDiffuse;
    }
    // vFinalColor = uMaterialDiffuse;
    
    
    //Transformed vertex position
    vec3 vecPosition = aVertexPosition; 
    if (uTranslate){
        vecPosition += uTranslation;
    }

    vec4 vertex = uMVMatrix * vec4(vecPosition, 1.0);

    //Transformed normal position
    vNormal = vec3(uNMatrix * vec4(aVertexNormal, 1.0));

    //Transformed light position
    vec4 light = vec4(uLightPosition,1.0);

    if(uUpdateLight){
        light = uMVMatrix * vec4(uLightPosition,1.0);
    }

    //Light position
    vLightRay = vertex.xyz-light.xyz;

    //Vector Eye
    vEyeVec = -vec3(vertex.xyz);

    //Final vertex position
    gl_Position = uPMatrix * vertex;

}	
</script>

<script id="shader-fs" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif

uniform bool uWireframe;
uniform vec4 uLightAmbient;
uniform vec4 uLightDiffuse;
uniform vec4 uLightSpecular;
uniform vec4 uMaterialAmbient;
uniform vec4 uMaterialDiffuse;
uniform vec4 uMaterialSpecular;
uniform float uShininess;       

varying vec3 vNormal;
varying vec3 vLightRay;
varying vec3 vEyeVec;
varying vec4 vFinalColor;

uniform bool uOffscreen; 

void main(void)
{
	if(uWireframe){
		gl_FragColor = vFinalColor;
	}
	else{
    	vec3 L = normalize(vLightRay);
    	vec3 N = normalize(vNormal);

    	//Lambert's cosine law
    	float lambertTerm = dot(N,-L);
    
    	//Ambient Term  
    	vec4 Ia = uLightAmbient * uMaterialAmbient;

    	//Diffuse Term
    	vec4 Id = vec4(0.0,0.0,0.0,1.0);

    	//Specular Term
    	vec4 Is = vec4(0.0,0.0,0.0,1.0);

    	if(lambertTerm > 0.0)
    	{
        	Id = uLightDiffuse * uMaterialDiffuse * lambertTerm; 
        	vec3 E = normalize(vEyeVec);
        	vec3 R = reflect(L, N);
        	float specular = pow( max(dot(R, E), 0.0), uShininess);
        	Is = uLightSpecular * uMaterialSpecular * specular;
    	}

    	//Final color
    	vec4 finalColor = Ia + Id + Is;
    	finalColor.a = 1.0;
    	gl_FragColor = finalColor;
    }

    if(uOffscreen){
        gl_FragColor = vFinalColor;
    }

}
</script>

<script id='code-js' type="text/javascript">

var camera      = null;
var interactor  = null;
var picker      = null;
var transforms  = null;
var showPickingImage    = false;

var ball = [];
var BALL_GRAVITY = 9.8;
var NUM_BALLS = 50;
var sceneTime = 0.0;

function generatePosition(){
    
    var x = Math.floor(Math.random()*40)+10;
    var y = Math.floor(Math.random()*10)+50;
    var z = Math.floor(Math.random()*40)+10;
    
    var flagX = Math.floor(Math.random()*10);
    var flagZ = Math.floor(Math.random()*10);
    
    if (flagX >= 5) {x=-x;}
    if (flagZ >= 5) {z=-z;}
    // y=0;
    return [x,y,z];
}

function BouncingBall(x,y,z){
    this.H0 = y;
    this.V0 = 0;
    this.VF = Math.sqrt(2 * BALL_GRAVITY * this.H0);
    this.HF = 0;
    this.bouncing_time  = 0;
    this.position = [x,y,z];
    // this.BOUNCINESS = (Math.random()+0.5);
    this.BOUNCINESS = (Math.random());
    // this.color = [Math.random(), Math.random(), Math.random(),1.0];
    this.color = [0.0, 0.0, 0.0,1.0];
    this.downStart = false;
    this.sceneTime = 0.0;
    this.is = 0;
    this.downSpeedX = (Math.random())-0.5;
    this.downSpeedZ = (Math.random());

    this.shininess = 0.1;
}

// var INITIAL_POSITION = [-25,0,20];
var FINAL_POSITION = [0,10,0];
var ISTEPS = 100;
var position = [];
var is = 0;
var xPos = 0.1;

var DOWN_AREA = [1,9,1];

BouncingBall.prototype.update = function(time){
    
    if(typeof this.originposition === 'undefined'){
        this.originposition = [this.position[0],this.position[1],this.position[2]];
    };
   
    var X0 = this.originposition[0];
    var Y0 = this.originposition[1];
    var Z0 = this.originposition[2];
    
    // console.log('X0 : ' + X0);
    // console.log('Y0 : ' + Y0);
    // console.log('Z0 : ' + Z0);

    var X1 = FINAL_POSITION[0];
    var Y1 = FINAL_POSITION[1];
    var Z1 = FINAL_POSITION[2];
    
    DOWN_AREA[0] = Math.abs(FINAL_POSITION[0]) + 1;
    DOWN_AREA[1] = Math.abs(FINAL_POSITION[1]) - 1;
    DOWN_AREA[2] = Math.abs(FINAL_POSITION[2]) + 1;

    var dX = (X1 - X0)/ISTEPS;
    var dY = (Y1 - Y0)/ISTEPS;
    var dZ = (Z1 - Z0)/ISTEPS;
    if(this.is < ISTEPS){
        // this.originposition = [this.position[0],this.position[1],this.position[2]];
        // console.log('this.position[0] : ' + this.position[0]);
        // console.log('this.position[1] : ' + this.position[1]);
        // console.log('this.position[2] : ' + this.position[2]);
        if(this.position[2] > 50){
            this.downStart = false;
            this.position = [this.originposition[0],this.originposition[1],this.originposition[2]];
            this.is = 0;
            this.H0 = this.position[1];
            this.VF = Math.sqrt(2 * BALL_GRAVITY * this.H0);
            this.sceneTime = 0;
            this.bouncing_time = 0;
            // this.is = 0;
        }
        if(!this.downStart && Math.abs(this.position[0]) <= DOWN_AREA[0] 
            && Math.abs(this.position[1]) >= DOWN_AREA[1]
            && Math.abs(this.position[2]) <= DOWN_AREA[2]){
            this.downStart = true;
            this.H0 = this.position[1];
            this.VF = Math.sqrt(2 * BALL_GRAVITY * this.H0);
            this.position = [this.position[0],this.position[1],this.position[2]];
            this.sceneTime = 0;

        };
        
        if(this.downStart){
            this.sceneTime += 33/1000;   //simulation time
            // var pos = generatePosition();
            // this.position[0] = this.originposition[0];
            // this.position[1] = this.originposition[1];
            // this.position[2] = this.originposition[2];
            // this.originposition[0] = pos[0];
            // this.originposition[1] = pos[1];
            // this.originposition[2] = pos[2];
            // this.position[0] = X0-(dX*is);
            // this.position[1] = Y0-(dY*is);
            // this.position[2] = Z0-(dZ*is);
            // is = 0;
            // this.down(time);
            // is = 0;
            
            var t = this.sceneTime - this.bouncing_time;
    
            //update positioon
            var h  = this.position[1]; // y-coordinate
            h = this.H0 + (this.V0 * t) - (0.5 * BALL_GRAVITY * t * t);

            // console.log('h :' +h);
            if(this.position[1] <= 0.001){
                this.position[2] = this.position[2] + 0.15;
            }else{
                if (h <= 0){ //bounce
                    this.bouncing_time = this.sceneTime;
                    this.V0 = this.VF * this.BOUNCINESS;
                    this.HF = (this.V0 * this.V0) / (2 * BALL_GRAVITY);
                    this.VF = Math.sqrt(2*BALL_GRAVITY* this.HF);
                    this.H0 = 0;
                }
                else{
                    this.position[1] = h;
                    // this.position[1] = this.position[1] + xPos;
                }
                this.position[0] = this.position[0] + this.downSpeedX;
                this.position[2] = this.position[2] + this.downSpeedZ;
            }
            this.is = 0;
        }else{
            this.shininess = Math.floor(Math.random()*5) +0.1;
            this.position[0] = X0+(dX*this.is);
            this.position[1] = Y0+(dY*this.is);
            this.position[2] = Z0+(dZ*this.is);
            this.is++;

        }
        // is += 0.01;
        
    }else{
        this.is = 0;
        // app.refresh();
    }

}

BouncingBall.prototype.down = function(time){

    // console.log('down');
    // update time
    var t = time - this.bouncing_time;
    
    //update positioon
    var h  = this.position[1]; // y-coordinate
    h = this.H0 + (this.V0 * t) - (0.5 * BALL_GRAVITY * t * t);

    console.log('h :' +h);
    if (h <= 0){ //bounce
        this.bouncing_time = time;
        this.V0 = this.VF * this.BOUNCINESS;
        this.HF = (this.V0 * this.V0) / (2 * BALL_GRAVITY);
        this.VF = Math.sqrt(2*BALL_GRAVITY* this.HF);
        this.H0 = 0;
    }
    else{
        this.position[1] = h;
        // this.position[1] = this.position[1] + xPos;
    }
}

function configure(){
    // gl.clearColor(0.3,0.3,0.3, 1.0);
    // gl.clearDepth(100.0);
    // gl.enable(gl.DEPTH_TEST);
    // gl.depthFunc(gl.LEQUAL);
    
    // //Creates and sets up the camera location
    // camera = new Camera(CAMERA_ORBITING_TYPE);
    // camera.goHome([0,2,300]);
    // camera.setFocus([0.0,0.0,0.0]);
    // camera.hookRenderer = render;
    
    gl.clearColor(0.0,0.0,0.0, 1.0);
    gl.clearDepth(1.0);
    
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LESS);
    
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);

    
    //Creates and sets up the camera location
    camera = new Camera(CAMERA_ORBITING_TYPE);
    camera.goHome([0,10,100]);
    camera.setFocus([0.0,0.0,0.0]);
    camera.setElevation(-40);
    camera.setAzimuth(-30);
    camera.hookRenderer = render;

    var canvas  = document.getElementById('canvas-element-id');
    
    //Scene Picker
    picker = new Picker(canvas);
    picker.processHitsCallback = processHits;
    picker.addHitCallback      = addHit;
    picker.removeHitCallback   = removeHit;
    picker.hitPropertyCallback = hitProperty;
    picker.moveCallback        = movePickedObjects;
    
    //Creates and sets up the mouse and keyboard interactor
    interactor = new CameraInteractor(camera, canvas);
    interactor.setPicker(picker);
    
    //Scene Transforms
    transforms = new SceneTransforms(camera);
   
    //init transforms
    transforms.init();
    
    //create program variable that maps the uniform uTranslation
    prg.uTranslation   = gl.getUniformLocation(prg, "uTranslation");
    gl.uniform3fv(prg.uTranslation, [0,0,0]);
    
    //create program variable that maps the uniform uTranslate
    prg.uTranslate = gl.getUniformLocation(prg, "uTranslate");
    gl.uniform1i(prg.uTranslate, false);
    
    for (var i=0;i<NUM_BALLS;i++){
        var pos = generatePosition();
        ball.push(new BouncingBall(pos[0],pos[1],pos[2]));
    }
}


/**
* Loads the scene
*/
function load(){
    // Floor.build(80,2);
    // Axis.build(82);
    // Scene.addObject(Floor);
    
            // gl.uniform4fv(prg.uMaterialDiffuse, object.diffuse);
            // gl.uniform4fv(prg.uMaterialSpecular, object.specular);
            // gl.uniform4fv(prg.uMaterialAmbient, object.ambient);
            
            // gl.uniform1i(prg.uWireframe,object.wireframe);
            // gl.uniform1i(prg.uPerVertexColor, object.perVertexColor);
    Scene.loadObject('models/geometry/ball.json','ball');
    Scene.loadObject('models/geometry/flag.json','flagFin', {
        position:FINAL_POSITION,scale:[1,1.5,1], diffuse:[0.3,0.3,0.6,1.0],
        shininess:1000000.0
    });
}

function render(){

    //off-screen rendering
    gl.bindFramebuffer(gl.FRAMEBUFFER, picker.framebuffer);
    gl.uniform1i(prg.uOffscreen, true);
    draw();
    //on-screen rendering
    gl.uniform1i(prg.uOffscreen, showPickingImage);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    draw();
}

function hitProperty(ob){
    console.log('hitProperty');
    console.log('ob.diffuse : ' + JSON.stringify(ob.diffuse));
    return ob.diffuse;
}

function addHit(ob){
    console.log('addhit');
    ob.previous = ob.diffuse.slice(0);     
    ob.diffuse[3] = 0.5;
    render();
}

function removeHit(ob){
    console.log('removeHit');
    ob.diffuse = ob.previous.slice(0);
    render();

}

function processHits(hits){
    console.log('processHits');
    var names = '', ob;
    for(var i = 0; i < hits.length; i++){
        ob = hits[i];
        ob.diffuse = ob.previous;
        names += ob.alias + ' ';
    }
    render();
    $('#selected-id').html('You picked : ' + names);
}

function movePickedObjects(hits,interactor,dx,dy){
    console.log('movePickedObjects');
    if (hits == 0) return;
    
    var camera = interactor.camera;
    var depth =  interactor.alt;
    var factor = Math.max(Math.max(camera.position[0], camera.position[1]), camera.position[2])/1000;
    var scaleX, scaleY;
    for (var i = 0, max = hits.length; i < max; i+=1){

        scaleX = vec3.create();
        scaleY = vec3.create();
        
        if (depth){
            vec3.scale(camera.normal, dy * factor, scaleY);
        }
        else{
            vec3.scale(camera.up,    -dy * factor, scaleY);
            vec3.scale(camera.right,  dx * factor, scaleX);
        }

        vec3.add(hits[i].position, scaleY);
        vec3.add(hits[i].position, scaleX);

    }
    render();
}

function drawBall(ball, sphere){
    gl.uniform3fv(prg.uTranslation, ball.position);
    gl.uniform4fv(prg.uMaterialDiffuse, ball.color);
    gl.uniform1f(prg.uShininess,ball.shininess);
    gl.drawElements(gl.TRIANGLES, sphere.indices.length, gl.UNSIGNED_SHORT,0);
    
    
}

function drawBalls(object){
    gl.uniform4fv(prg.uMaterialSpecular, object.specular);
    gl.uniform4fv(prg.uMaterialAmbient, object.ambient);

    gl.uniform1i(prg.uWireframe,false);
    gl.uniform1i(prg.uPerVertexColor, false);
    gl.uniform1i(prg.uTranslate, true);

    //Setting Attributes
    gl.enableVertexAttribArray(prg.aVertexPosition);
    gl.disableVertexAttribArray(prg.aVertexNormal);
    gl.disableVertexAttribArray(prg.aVertexColor);
    
    //Setting Buffers
    gl.bindBuffer(gl.ARRAY_BUFFER, object.vbo);
    gl.vertexAttribPointer(prg.aVertexPosition, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(prg.aVertexPosition);
            
    gl.bindBuffer(gl.ARRAY_BUFFER, object.nbo);
    gl.vertexAttribPointer(prg.aVertexNormal, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(prg.aVertexNormal);
    
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, object.ibo);
    
    for(var j = 0; j < NUM_BALLS; j++){
        drawBall(ball[j],object);
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
}

/**
* invoked on every rendering cycle
*/
function draw() {
    gl.viewport(0, 0, c_width, c_height);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    transforms.updatePerspective();
    
    var offscreen  = gl.getUniform(prg, prg.uOffscreen);
    // console.log('offscreen : ' + offscreen);
    try{
        gl.uniform1i(prg.uUpdateLight,updateLightPosition);
        
        
        for (var i = 0; i < Scene.objects.length; i++){
            
            var object = Scene.objects[i];
			

			transforms.calculateModelView();           
            transforms.setMatrixUniforms();
            camera.setRotateAngle(angle);
            if (object.alias == 'flagFin'){
                // object.position[0] = object.position[0] + 0.01;
                mat4.translate(transforms.mvMatrix, object.position);
                mat4.scale(transforms.mvMatrix, object.scale);
                gl.uniform1f(prg.uShininess,1000000000.0);
                // gl.uniform1i(prg.uOffscreen, true);
                // gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                // continue;
            }
            else if (object.alias== 'ball'){
                // gl.uniform1i(prg.uOffscreen, false);
                // gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                drawBalls(object);
                continue;
            }
            transforms.setMatrixUniforms();
            // transforms.pop();
            
            gl.uniform1i(prg.uTranslate, false);
            

            //Setting uniforms
            gl.uniform4fv(prg.uMaterialDiffuse, object.diffuse);
            gl.uniform4fv(prg.uMaterialSpecular, object.specular);
            gl.uniform4fv(prg.uMaterialAmbient, object.ambient);
            
            gl.uniform1i(prg.uWireframe,object.wireframe);
            gl.uniform1i(prg.uPerVertexColor, object.perVertexColor);
            
            //Setting attributes
            gl.enableVertexAttribArray(prg.aVertexPosition);
            gl.disableVertexAttribArray(prg.aVertexNormal);
            gl.disableVertexAttribArray(prg.aVertexColor);

            gl.bindBuffer(gl.ARRAY_BUFFER, object.vbo);
            gl.vertexAttribPointer(prg.aVertexPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(prg.aVertexPosition);
            
            if(!object.wireframe){
                gl.bindBuffer(gl.ARRAY_BUFFER, object.nbo);
                gl.vertexAttribPointer(prg.aVertexNormal, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(prg.aVertexNormal);
            }
            
            if (object.perVertexColor){
                gl.bindBuffer(gl.ARRAY_BUFFER, object.cbo);
                gl.vertexAttribPointer(prg.aVertexColor,4,gl.FLOAT, false, 0,0);
                gl.enableVertexAttribArray(prg.aVertexColor);
            }
            
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, object.ibo);
            
            if (object.wireframe){
                gl.drawElements(gl.LINES, object.indices.length, gl.UNSIGNED_SHORT,0);
            }
            else{
                gl.drawElements(gl.TRIANGLES, object.indices.length, gl.UNSIGNED_SHORT,0);
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            
        }
    }
    catch(err){
        alert(err);
        console.error(err.description);
    }
}

var animationRate = 15; /* 15 ms */
var elapsedTime = undefined;
var initialTime = undefined;
var angle = 0;
function animate(){
    for (var i = 0; i<ball.length; i++){
        ball[i].update(sceneTime);
    }
    sceneTime += 33/1000;	//simulation time
	draw();
}

function onFrame() {
	elapsedTime = (new Date).getTime() - initialTime;
	if (elapsedTime < animationRate) { return;} //come back later
	var steps = Math.floor(elapsedTime / animationRate);
    while(steps > 0){
        animate();
        steps -= 1;
    }
    angle += (90 * elapsedTime) / 10000.0;
	initialTime = (new Date).getTime();
}

function startAnimation(){
	initialTime = (new Date).getTime();
	setInterval(onFrame,animationRate/1000); // animation rate
}


/**
* Entry point. This function is invoked when the page is loaded
*/
var app = null;
function runWebGLApp() {
    app = new WebGLApp("canvas-element-id")
    app.configureGLHook = configure;
    app.loadSceneHook   = load;
    app.drawSceneHook   = render;
    app.run();
    
    startAnimation();

}
</script>
</head>

<body onLoad='runWebGLApp()'>

<canvas id='canvas-element-id' width='1000' height='400'>
Your browser does not support the HTML5 canvas element.


<div id='bottom'>
<table style='padding=0px'>
<tr>
    <td> 
    <table cellspacing=4px style='vertical-align:top'>
        <tr>
            <td align='center'>
            <div id='opt-type' >
                    <input type='radio' id='opt-tracking' name='typecam' /><label for='opt-tracking'>Tracking</label>
                    <input type='radio' id='opt-orbiting' name='typecam' checked='checked'/><label for='opt-orbiting'>Orbiting</label>
            </div>
            </td>
            <td align='center'>
            <button id='btnGoHome'>Go Home</button>
            <input type="checkbox" id="chkUpdateLight" /><label for="chkUpdateLight">Fixed Light Source</label>
            </td>
        </tr>
    </table>
    </td>
</tr>
</table>
</div>
<script> 

$('#chkUpdateLight').button();
$('#opt-type').buttonset();
$('#btnGoHome').button();


$('#chkUpdateLight').click(toggleLight);

$('#opt-tracking').click(function(){
    camera.goHome();
    console.info('CameraType = Tracking');
    camera.setType(CAMERA_TRACKING_TYPE);
    
    app.refresh();
});

$('#opt-orbiting').click(function(){
    camera.goHome();
    console.info('CameraType = Orbiting');
    camera.setType(CAMERA_ORBITING_TYPE);
    app.refresh();
});


var updateLightPosition = false;

function toggleLight(){
    updateLightPosition = !updateLightPosition;
}

$('#btnGoHome').click(
    function(){
        camera.goHome();
        app.refresh();
});



</script>
</body>
</html>